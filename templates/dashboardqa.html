<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZeddyBot Dashboard</title>

    <!-- Favicon using emoji -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🤖</text></svg>">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .header h1 {
            color: white;
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1.15fr 1fr 1fr 1fr;
            grid-template-rows: repeat(2, auto);
            gap: 1.2rem;
            margin-bottom: 2rem;
        }

        .obs-column {
            grid-column: 6;
            grid-row: 1 / 3;
            /* Takes up both rows of the 6th column */
        }

        @media (max-width: 1400px) {
            .grid {
                grid-template-columns: repeat(4, 1fr);
                grid-template-rows: repeat(3, auto);
            }

            .obs-column {
                grid-column: 4;
                grid-row: 1 / 3;
            }
        }

        @media (max-width: 1000px) {
            .grid {
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: auto;
            }

            .obs-column {
                grid-column: 1 / -1;
                /* Full width on smaller screens */
                grid-row: auto;
            }
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1.1rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card h2 {
            margin-bottom: 0.4rem;
            color: #4a5568;
            font-size: 1.15rem;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-live {
            background: #48bb78;
            animation: pulse-live 2s infinite;
            box-shadow: 0 0 8px rgba(72, 187, 120, 0.6);
        }

        .status-offline {
            background: #e53e3e;
        }

        .status-connected {
            background: #38b2ac;
        }

        @keyframes pulse-live {
            0% {
                box-shadow: 0 0 8px rgba(72, 187, 120, 0.6);
            }
            50% {
                box-shadow: 0 0 15px rgba(72, 187, 120, 0.8);
            }
            100% {
                box-shadow: 0 0 8px rgba(72, 187, 120, 0.6);
            }
        }

        .stream-info {
            background: linear-gradient(135deg, #9146ff, #772ce8);
            color: white;
        }

        .stream-info h2 {
            color: white;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 0.3rem 0;
            padding: 0.3rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .chat-form {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .chat-input {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .chat-input:focus {
            outline: none;
            border-color: #9146ff;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #9146ff, #772ce8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .history-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            padding: 0.75rem;
            margin: 0.5rem 0;
            background: rgba(79, 70, 229, 0.1);
            border-radius: 8px;
            border-left: 4px solid #9146ff;
        }

        .history-title {
            font-weight: 600;
            color: #4c51bf;
        }

        .history-meta {
            font-size: 0.8rem;
            color: #718096;
            margin-top: 0.25rem;
        }

        .watchlist {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        .watchlist-item {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .refresh-btn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #9146ff, #772ce8);
            color: white;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(145, 70, 255, 0.4);
            transition: transform 0.2s;
        }

        .refresh-btn:hover {
            transform: scale(1.1);
        }

        /* Bot Moderation styles removed due to TwitchInsights being discontinued */

        /* Status indicator styles */
        .status-indicator {
            text-align: center;
            padding: 0.5rem 0.25rem;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.2s ease;
        }

        .status-indicator:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .system-status-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem 0;
        }

        @media (max-width: 768px) {
            .system-status-grid {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
        }

        @media (max-width: 480px) {
            .system-status-grid {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
        }

        .status-dot {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            display: block;
            line-height: 1.2;
            transition: all 0.3s ease;
            text-align: center;
            width: 100%;
        }

        .status-dot.online {
            color: #48bb78;
            text-shadow: 0 0 8px rgba(72, 187, 120, 0.5);
        }

        .status-dot.offline {
            color: #f56565;
            text-shadow: 0 0 8px rgba(245, 101, 101, 0.5);
        }

        .status-dot.warning {
            color: #ed8936;
            text-shadow: 0 0 8px rgba(237, 137, 54, 0.5);
        }

        .status-label {
            font-size: 0.65rem;
            color: #a0aec0;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            line-height: 1.1;
        }

        /* Scene button specific styles */
        .scene-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            margin: 0.25rem;
            min-width: 100px;
            font-size: 0.875rem;
        }

        .scene-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.3);
        }

        .scene-button.active {
            background: linear-gradient(135deg, #48bb78, #38a169);
            box-shadow: 0 2px 8px rgba(72, 187, 120, 0.3);
        }

        /* Success/Error message styles */
        .success-message {
            background: rgba(72, 187, 120, 0.1);
            color: #48bb78;
            border: 1px solid rgba(72, 187, 120, 0.3);
        }

        .error-message {
            background: rgba(245, 101, 101, 0.1);
            color: #f56565;
            border: 1px solid rgba(245, 101, 101, 0.3);
        }

        .warning-message {
            background: rgba(237, 137, 54, 0.1);
            color: #ed8936;
            border: 1px solid rgba(237, 137, 54, 0.3);
        }

        .status-success {
            background: rgba(72, 187, 120, 0.1);
            border: 1px solid rgba(72, 187, 120, 0.3);
            color: #38a169;
        }

        .status-error {
            background: rgba(229, 62, 62, 0.1);
            border: 1px solid rgba(229, 62, 62, 0.3);
            color: #e53e3e;
        }

        .status-warning {
            background: rgba(237, 137, 54, 0.1);
            border: 1px solid rgba(237, 137, 54, 0.3);
            color: #dd6b20;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .loading {
            animation: pulse 1.5s infinite;
        }

        /* Q&A styles */
        .chat-message {
            padding: 8px;
            margin: 2px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .chat-message:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .qna-controls {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            margin-bottom: 1rem;
        }

        .qna-controls h2 {
            color: white;
        }

        .current-question {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .qna-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        /* Bot stats styling */
        .bot-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .bot-stat-item {
            text-align: center;
            padding: 0.5rem;
            background: rgba(145, 70, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(145, 70, 255, 0.2);
        }

        .bot-stat-number {
            font-size: 1.2rem;
            font-weight: 700;
            color: #9146ff;
            margin-bottom: 0.2rem;
        }

        .bot-stat-label {
            font-size: 0.7rem;
            color: #718096;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .mod-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .mod-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
        }

        .mod-button.warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🤖 ZeddyBot Dashboard</h1>
        </div>

        <div class="grid">
            <!-- Row 1: System Status Cards -->
            <div class="card stream-info">
                <h2>
                    <span class="status-indicator" id="stream-status"></span>
                    Stream Status
                </h2>

                <div class="stat-row">
                    <span>Status:</span>
                    <span id="stream-live">Checking...</span>
                </div>

                <div class="stat-row">
                    <span>Title:</span>
                    <span id="stream-title">-</span>
                </div>

                <div class="stat-row">
                    <span>Game:</span>
                    <span id="stream-game">-</span>
                </div>

                <div class="stat-row">
                    <span>Viewers:</span>
                    <span id="stream-viewers">0</span>
                </div>
            </div>

            <div class="card">
                <h2>
                    <span class="status-indicator status-connected"></span>
                    Bot Status
                </h2>

                <div class="stat-row">
                    <span>Discord:</span>
                    <span id="bot-discord-status" style="color: #48bb78;">Connected</span>
                </div>

                <div class="stat-row">
                    <span>Twitch Chat:</span>
                    <span id="bot-twitch-status" style="color: #48bb78;">Connected</span>
                </div>

                <div class="stat-row">
                    <span>Last Update:</span>
                    <span id="last-update">-</span>
                </div>
            </div>

            <div class="card system-status-card">
                <h2>⚙️ System Status</h2>

                <div class="system-status-grid">
                    <div class="status-indicator">
                        <div class="status-dot" id="system-discord-status">●</div>
                        <div class="status-label">Discord Bot</div>
                    </div>
                    <div class="status-indicator">
                        <div class="status-dot" id="system-twitch-status">●</div>
                        <div class="status-label">Twitch Chat</div>
                    </div>
                    <div class="status-indicator">
                        <div class="status-dot" id="system-obs-status">●</div>
                        <div class="status-label">OBS WebSocket</div>
                    </div>
                </div>

                <div style="display: flex; flex-wrap: wrap; gap: 0.3rem; justify-content: center; margin-top: 4.5rem;">
                    <button onclick="testChatConnection()"
                        style="background: #3498db; color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 6px; cursor: pointer; font-size: 0.75rem; font-weight: 600;">
                        🔗 Test Chat
                    </button>
                    <button onclick="pingDashboard()"
                        style="background: #2ecc71; color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 6px; cursor: pointer; font-size: 0.75rem; font-weight: 600;">
                        📡 Ping Dashboard
                    </button>
                    <button onclick="reconnectOBS()"
                        style="background: #e67e22; color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 6px; cursor: pointer; font-size: 0.75rem; font-weight: 600;">
                        🎥 Reconnect OBS
                    </button>
                </div>
                <div id="system-status-message" style="margin-top: 0.5rem; font-size: 0.9rem;"></div>
            </div>

            <div class="card">
                <h2>💬 Discord Control</h2>

                <div class="bot-stats" style="margin-bottom: 1rem;">
                    <div class="bot-stat-item">
                        <div class="bot-stat-number" id="discord-members">-</div>
                        <div class="bot-stat-label">Discord Online</div>
                    </div>
                    <div class="bot-stat-item">
                        <div class="bot-stat-number" id="discord-server-members">-</div>
                        <div class="bot-stat-label">Total Members</div>
                    </div>
                </div>

                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;">
                    <button class="mod-button" onclick="forceNotification()" style="background: #9146ff;">
                        🔔 Force Notify
                    </button>
                    <button class="mod-button" onclick="testNotification()" style="background: #00d4aa;">
                        🧪 Test Notify
                    </button>
                    <button class="mod-button warning" onclick="refreshBotToken()">
                        🔄 Refresh Token
                    </button>
                </div>
                <div id="stream-control-status" style="margin-top: 0.5rem; font-size: 0.9rem;"></div>
            </div>

            <div class="card">
                <h2>💬 Send Chat Message</h2>
                <div class="chat-form">
                    <input type="text" class="chat-input" id="chat-message" placeholder="Type your message...">
                    <button class="btn" onclick="sendChatMessage()">Send</button>
                </div>
                <div id="chat-response" style="margin-top: 0.5rem; font-size: 0.9rem;"></div>
                
                <!-- Quick Chat Messages integrated here -->
                <div style="margin-top: 1rem;">
                    <h3 style="font-size: 0.9rem; margin-bottom: 0.5rem; color: rgb(0, 0, 0);">Quick Messages:</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.4rem;">
                        <button class="mod-button" onclick="sendQuickMessage('welcome')" style="background: #3498db; font-size: 0.75rem; padding: 0.4rem;">
                            👋 Welcome
                        </button>
                        <button class="mod-button" onclick="sendQuickMessage('follow')" style="background: #e74c3c; font-size: 0.75rem; padding: 0.4rem;">
                            ❤️ Follow
                        </button>
                        <button class="mod-button" onclick="sendQuickMessage('brb')" style="background: #f39c12; font-size: 0.75rem; padding: 0.4rem;">
                            ⏰ BRB
                        </button>
                        <button class="mod-button" onclick="sendQuickMessage('ending')" style="background: #9b59b6; font-size: 0.75rem; padding: 0.4rem;">
                            👋 Ending
                        </button>
                        <button class="mod-button" onclick="sendQuickMessage('lurk')" style="background: #95a5a6; font-size: 0.75rem; padding: 0.4rem;">
                            👀 Lurk
                        </button>
                    </div>
                </div>
                <div id="quick-message-status" style="margin-top: 0.5rem; font-size: 0.9rem;"></div>
            </div>

            <!-- OBS Scene Control Card - Takes half of 4th column -->
            <div class="card obs-column">
                <h2>🎥 OBS Scene Control</h2>
                <div id="obs-status"
                    style="margin-bottom: 1rem; padding: 0.5rem; border-radius: 5px; background: #f39c12; color: white; text-align: center;">
                    Loading OBS status...
                </div>

                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin-bottom: 1rem;"
                    id="scene-buttons">
                    <!-- Scene buttons will be populated by JavaScript -->
                </div>
            </div>

            <!-- Row 2: Q&A control and Chat Section -->
            <!-- Live Chat Card - Main Q&A Feature -->
            <div class="card" style="grid-column: span 4;">
                <h2>💬 Live Chat</h2>
                <div id="chat-messages"
                    style="height: 300px; max-height: 300px; overflow-y: auto; padding: 1rem; background: linear-gradient(135deg, #1a1446 0%, #2d0036 100%); border-radius: 8px; box-shadow: 0 2px 8px rgba(255,0,255,0.15); border: 1.5px solid #ff00cc;">
                </div>
                <div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">
                    Click on any message to display it as a Q&A
                </div>
            </div>
            <div class="card qna-controls">
                <h2>🎭 Q&amp;A Control</h2>
                <div id="current-question-display">
                    <p>No question selected. Click on a chat message to display it.</p>
                </div>
                <div class="qna-buttons">
                    <button class="btn" onclick="hideQuestion()" style="background: #e74c3c;">Hide Question</button>
                    <button class="btn" onclick="refreshQuestion()" style="background: #3498db;">Refresh</button>
                </div>
                <div style="margin-top: 1rem;">
                    <h3 style="font-size: 0.9rem; margin-bottom: 0.5rem; color: white;">Q&A Theme:</h3>
                    <div style="display: flex; gap: 0.3rem; flex-wrap: wrap;">
                        <button onclick="setQnaTheme('default')"
                            style="background: #9146ff; color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">Purple</button>
                        <button onclick="setQnaTheme('green')"
                            style="background: #48bb78; color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">Green</button>
                        <button onclick="setQnaTheme('blue')"
                            style="background: #3498db; color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">Blue</button>
                        <button onclick="setQnaTheme('red')"
                            style="background: #e74c3c; color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">Red</button>
                        <button onclick="setQnaTheme('orange')"
                            style="background: #f39c12; color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">Orange</button>
                    </div>
                </div>
                <div id="qna-theme-status" style="margin-top: 0.5rem; font-size: 0.8rem;"></div>
            </div>
        </div>

        <button class="refresh-btn" onclick="loadData()" title="Refresh Data">
            ↻
        </button>

        <script>
            // Q&A and Chat Integration

            function updateChat() {
                fetch('/api/chat')
                    .then(response => response.json())
                    .then(messages => {
                        const chatDiv = document.getElementById('chat-messages');
                        const isNearTop = chatDiv.scrollTop < 60;
                        chatDiv.innerHTML = '';
                        messages.slice().reverse().forEach(msg => {
                            addMessageToChat(msg);
                        });
                        if (isNearTop) {
                            chatDiv.scrollTop = 0;
                        }
                    })
                    .catch(err => console.error('Chat update error:', err));
            }

            function addMessageToChat(msg) {
                const chatDiv = document.getElementById('chat-messages');
                const msgDiv = document.createElement('div');
                msgDiv.className = 'chat-message';
                msgDiv.onclick = () => displayQuestion(msg.username, msg.message);
                msgDiv.innerHTML = `<span style="color:#ffe066;">[${msg.timestamp}]</span> <strong style="color:#00fff7;">${msg.username}:</strong> <span style="color:#ff61f6;">${msg.message}</span>`;
                
                // Insert at the top (most recent first)
                chatDiv.insertBefore(msgDiv, chatDiv.firstChild);
                
                // Limit to last 50 messages to prevent memory issues
                while (chatDiv.children.length > 50) {
                    chatDiv.removeChild(chatDiv.lastChild);
                }
            }

            // Initialize real-time chat with Server-Sent Events
            function initRealTimeChat() {
                const eventSource = new EventSource('/api/chat/stream');
                
                eventSource.onmessage = function(event) {
                    try {
                        const messageData = JSON.parse(event.data);
                        
                        if (messageData.type === 'heartbeat') {
                            return; // Ignore heartbeat messages
                        }
                        
                        // Add new message to chat immediately
                        addMessageToChat(messageData);
                        console.log('[CHAT] Real-time message received:', messageData.username + ': ' + messageData.message);
                        
                    } catch (error) {
                        console.error('[CHAT] Error parsing SSE message:', error);
                    }
                };
                
                eventSource.onerror = function(event) {
                    console.log('[CHAT] SSE connection error, will auto-reconnect');
                };
                
                eventSource.onopen = function(event) {
                    console.log('[CHAT] Real-time chat connected');
                };
                
                return eventSource;
            }

            // Q&A functions
            async function displayQuestion(username, message) {
                try {
                    const response = await fetch('/api/display_question', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, message })
                    });

                    const result = await response.json();
                    if (result.success) {
                        updateCurrentQuestion(username, message);
                    } else {
                        alert('Failed to display question: ' + (result.error || result.message));
                    }
                } catch (error) {
                    alert('Error displaying question: ' + error.message);
                }
            }

            async function hideQuestion() {
                try {
                    const response = await fetch('/api/hide_question', {
                        method: 'POST'
                    });

                    const result = await response.json();
                    if (result.success) {
                        clearCurrentQuestion();
                    }
                } catch (error) {
                    alert('Error hiding question: ' + error.message);
                }
            }

            function updateCurrentQuestion(username, message) {
                const display = document.getElementById('current-question-display');
                display.innerHTML = `
                <div class="current-question">
                    <p><strong>Q:</strong> ${message}</p>
                    <p><em>— ${username}</em></p>
                </div>
            `;
            }

            function clearCurrentQuestion() {
                const display = document.getElementById('current-question-display');
                display.innerHTML = '<p>No question selected. Click on a chat message to display it.</p>';
            }

            async function refreshQuestion() {
                try {
                    const response = await fetch('/api/current_question');
                    const question = await response.json();

                    if (question && question.username && question.message) {
                        updateCurrentQuestion(question.username, question.message);
                    } else {
                        clearCurrentQuestion();
                    }
                } catch (error) {
                    clearCurrentQuestion();
                }
            }

            async function setQnaTheme(theme) {
                try {
                    const response = await fetch('/api/qna_theme', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ theme: theme })
                    });

                    const result = await response.json();
                    const statusDiv = document.getElementById('qna-theme-status');

                    if (result.success) {
                        statusDiv.style.color = '#48bb78';
                        statusDiv.textContent = `✓ Theme set to ${result.theme}`;
                    } else {
                        statusDiv.style.color = '#e53e3e';
                        statusDiv.textContent = '✗ ' + (result.error || 'Failed to set theme');
                    }

                    setTimeout(() => statusDiv.textContent = '', 3000);

                } catch (error) {
                    const statusDiv = document.getElementById('qna-theme-status');
                    statusDiv.style.color = '#e53e3e';
                    statusDiv.textContent = '✗ Connection error';
                    setTimeout(() => statusDiv.textContent = '', 3000);
                }
            }

            // Initialize real-time chat instead of polling
            let chatEventSource;
            
            setInterval(refreshQuestion, 15000);  // Keep Q&A refresh interval
            
            // Load initial chat history
            updateChat();
            
            // Start real-time chat updates
            chatEventSource = initRealTimeChat();
            
            refreshQuestion();
            
            // Clean up SSE connection when page is unloaded
            window.addEventListener('beforeunload', function() {
                if (chatEventSource) {
                    chatEventSource.close();
                    console.log('[CHAT] SSE connection closed');
                }
            });

            // Dashboard data and chat send
            async function loadData() {
                try {
                    const response = await fetch('/api/status');
                    const data = await response.json();

                    // Update stream status
                    const streamStatus = document.getElementById('stream-status');
                    const streamLive = document.getElementById('stream-live');

                    if (data.stream.live) {
                        streamStatus.className = 'status-indicator status-live';
                        streamLive.textContent = 'LIVE';
                        document.getElementById('stream-title').textContent = data.stream.title || 'No Title';
                        document.getElementById('stream-game').textContent = data.stream.game || 'No Game';
                        document.getElementById('stream-viewers').textContent = data.stream.viewers.toLocaleString();
                        
                        // Store stream status for other functions to use
                        window.currentStreamStatus = { isLive: true, lastUpdate: Date.now() };
                    } else {
                        streamStatus.className = 'status-indicator status-offline';
                        streamLive.textContent = 'Offline';
                        document.getElementById('stream-title').textContent = '-';
                        document.getElementById('stream-game').textContent = '-';
                        document.getElementById('stream-viewers').textContent = '0';
                        
                        // Store stream status for other functions to use
                        window.currentStreamStatus = { isLive: false, lastUpdate: Date.now() };
                    }

                    // Update last update time
                    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();

                } catch (error) {
                    console.error('Error loading data:', error);
                    // On error, mark as offline
                    window.currentStreamStatus = { isLive: false, lastUpdate: Date.now() };
                }
            }

            async function sendChatMessage() {
                const input = document.getElementById('chat-message');
                const response = document.getElementById('chat-response');
                const message = input.value.trim();

                if (!message) return;

                try {
                    const result = await fetch('/api/send_chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message })
                    });

                    const data = await result.json();

                    if (data.success) {
                        response.style.color = '#48bb78';
                        response.textContent = '✓ Message sent successfully';
                        input.value = '';
                    } else {
                        response.style.color = '#e53e3e';
                        response.textContent = '✗ ' + (data.error || 'Failed to send message');
                    }

                    setTimeout(() => response.textContent = '', 3000);

                } catch (error) {
                    response.style.color = '#e53e3e';
                    response.textContent = '✗ Connection error';
                    setTimeout(() => response.textContent = '', 3000);
                }
            }

            // Allow Enter key to send chat message
            document.getElementById('chat-message').addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });

            // Bot Moderation functionality removed due to TwitchInsights being discontinued

            // ========== NEW DASHBOARD FUNCTIONS ==========

            // OBS Scene Control Functions
            async function loadOBSScenes() {
                try {
                    // Use dedicated status endpoint that doesn't trigger auto-reconnection
                    const statusResponse = await fetch('/api/obs_status');
                    const statusResult = await statusResponse.json();

                    const obsStatus = document.getElementById('obs-status');
                    const sceneButtons = document.getElementById('scene-buttons');

                    if (statusResult.connected) {
                        // OBS is connected, get scenes
                        const scenesResponse = await fetch('/api/obs_scenes');
                        const scenesResult = await scenesResponse.json();

                        if (scenesResult.success) {
                            obsStatus.textContent = statusResult.message;
                            obsStatus.style.background = '#27ae60';

                            sceneButtons.innerHTML = '';
                            // Filter to only show scenes that start with "Scene - " and reverse the order
                            const mainScenes = scenesResult.scenes.filter(scene => scene.startsWith('Scene - ')).reverse();
                            mainScenes.forEach(scene => {
                                const button = document.createElement('button');
                                button.className = `scene-button ${scene === scenesResult.current_scene ? 'active' : ''}`;
                                button.textContent = scene;
                                button.onclick = () => changeScene(scene);
                                sceneButtons.appendChild(button);
                            });
                        } else {
                            obsStatus.textContent = 'OBS Scene Error';
                            obsStatus.style.background = '#e74c3c';
                            sceneButtons.innerHTML = '';
                        }
                    } else {
                        // OBS not connected
                        obsStatus.textContent = statusResult.message;
                        obsStatus.style.background = '#e74c3c';
                        sceneButtons.innerHTML = '';
                    }
                } catch (error) {
                    const obsStatus = document.getElementById('obs-status');
                    obsStatus.textContent = 'OBS Connection Error';
                    obsStatus.style.background = '#e74c3c';
                    document.getElementById('scene-buttons').innerHTML = '';
                }
            }

            async function changeScene(sceneName) {
                try {
                    const response = await fetch('/api/obs_scene', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ scene_name: sceneName })
                    });

                    const result = await response.json();

                    if (result.success) {
                        // Update active scene button
                        document.querySelectorAll('.scene-button').forEach(btn => {
                            btn.classList.remove('active');
                            if (btn.textContent === sceneName) {
                                btn.classList.add('active');
                            }
                        });
                        showMessage('obs-status', result.message, 'success');
                    } else {
                        showMessage('obs-status', 'Failed to change scene: ' + result.error, 'error');
                    }
                } catch (error) {
                    showMessage('obs-status', 'Connection error: ' + error.message, 'error');
                }
            }

            async function toggleQnASource(enabled) {
                try {
                    const response = await fetch('/api/obs_toggle_source', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            scene_name: 'Scene - In Game',
                            source_name: 'QnA_Text',
                            enabled: enabled
                        })
                    });

                    const result = await response.json();
                    showMessage('obs-status', result.message || (enabled ? 'Q&A Shown' : 'Q&A Hidden'), result.success ? 'success' : 'error');
                } catch (error) {
                    showMessage('obs-status', 'Error toggling Q&A: ' + error.message, 'error');
                }
            }

            // Quick Messages Functions
            async function sendQuickMessage(messageType) {
                try {
                    showMessage('quick-message-status', 'Sending message...', 'warning');

                    const response = await fetch('/api/quick_messages', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type: messageType })
                    });

                    const result = await response.json();

                    if (result.success) {
                        showMessage('quick-message-status', result.message, 'success');
                    } else {
                        showMessage('quick-message-status', 'Failed: ' + result.error, 'error');
                    }
                } catch (error) {
                    showMessage('quick-message-status', 'Connection error: ' + error.message, 'error');
                }
            }

            // Stream Control Functions
            async function forceNotification() {
                try {
                    showMessage('stream-control-status', 'Sending notification...', 'warning');

                    const response = await fetch('/api/force_notification', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    const result = await response.json();
                    showMessage('stream-control-status', result.message, result.success ? 'success' : 'error');
                } catch (error) {
                    showMessage('stream-control-status', 'Connection error: ' + error.message, 'error');
                }
            }

            async function testNotification() {
                try {
                    showMessage('stream-control-status', 'Sending test notification...', 'warning');

                    const response = await fetch('/api/test_notification', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    const result = await response.json();
                    showMessage('stream-control-status', result.message, result.success ? 'success' : 'error');
                } catch (error) {
                    showMessage('stream-control-status', 'Connection error: ' + error.message, 'error');
                }
            }

            async function refreshBotToken() {
                try {
                    showMessage('stream-control-status', 'Refreshing token...', 'warning');

                    const response = await fetch('/api/refresh_token', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    const result = await response.json();
                    showMessage('stream-control-status', result.message, result.success ? 'success' : 'error');
                } catch (error) {
                    showMessage('stream-control-status', 'Connection error: ' + error.message, 'error');
                }
            }

            // System Status Functions
            async function testChatConnection() {
                try {
                    showMessage('system-status-message', 'Testing chat connection...', 'warning');

                    const response = await fetch('/api/test_chat');
                    const result = await response.json();
                    showMessage('system-status-message', result.message, result.success ? 'success' : 'error');
                } catch (error) {
                    showMessage('system-status-message', 'Connection error: ' + error.message, 'error');
                }
            }

            async function pingDashboard() {
                try {
                    showMessage('system-status-message', 'Pinging dashboard...', 'warning');

                    const response = await fetch('/api/ping');
                    const result = await response.json();
                    showMessage('system-status-message', result.message, 'success');
                } catch (error) {
                    showMessage('system-status-message', 'Dashboard unreachable: ' + error.message, 'error');
                }
            }

            async function reconnectOBS() {
                try {
                    showMessage('system-status-message', 'Reconnecting to OBS...', 'warning');

                    const response = await fetch('/api/obs_reconnect', {
                        method: 'POST'
                    });
                    const result = await response.json();

                    if (result.success) {
                        showMessage('system-status-message', result.message, 'success');
                        // Refresh OBS scenes and status after successful reconnection
                        setTimeout(() => {
                            loadOBSScenes();
                            updateSystemStatus();
                        }, 1000);
                    } else {
                        showMessage('system-status-message', result.message, 'error');
                    }
                } catch (error) {
                    showMessage('system-status-message', 'OBS reconnect error: ' + error.message, 'error');
                }
            }

            // System Status Updates
            async function updateSystemStatus() {
                try {
                    // Check Discord status
                    const discordResponse = await fetch('/api/discord_stats');
                    const discordData = await discordResponse.json();

                    const systemDiscordStatus = document.getElementById('system-discord-status');
                    const discordMembers = document.getElementById('discord-members');
                    const discordServerMembers = document.getElementById('discord-server-members');

                    if (discordData.success && discordData.stats.bot_connected) {
                        systemDiscordStatus.className = 'status-dot online';
                        if (discordMembers) discordMembers.textContent = discordData.stats.online_members;
                        // Use total_humans to exclude bots from the count, or total_members to include everything
                        if (discordServerMembers) discordServerMembers.textContent = discordData.stats.total_humans || discordData.stats.total_members || '-';
                    } else {
                        systemDiscordStatus.className = 'status-dot offline';
                        if (discordMembers) discordMembers.textContent = '0';
                        if (discordServerMembers) discordServerMembers.textContent = '-';
                    }

                    // Test Twitch chat connection
                    const twitchResponse = await fetch('/api/test_chat');
                    const twitchData = await twitchResponse.json();

                    const systemTwitchStatus = document.getElementById('system-twitch-status');
                    systemTwitchStatus.className = twitchData.success ? 'status-dot online' : 'status-dot offline';

                    // Check OBS connection using dedicated status endpoint
                    const obsResponse = await fetch('/api/obs_status');
                    const obsData = await obsResponse.json();

                    const systemObsStatus = document.getElementById('system-obs-status');
                    systemObsStatus.className = obsData.connected ? 'status-dot online' : 'status-dot offline';

                    // Use cached stream status from loadData instead of making duplicate API calls
                    // This prevents conflicts and flicker in the stream status indicator
                    if (window.currentStreamStatus) {
                        const streamStatusDot = document.getElementById('stream-status');
                        if (streamStatusDot) {
                            // Only update if the cached status is recent (within 2 minutes)
                            const timeSinceUpdate = Date.now() - window.currentStreamStatus.lastUpdate;
                            if (timeSinceUpdate < 120000) { // 2 minutes
                                const isLive = window.currentStreamStatus.isLive;
                                streamStatusDot.className = isLive ? 'status-indicator status-live' : 'status-indicator status-offline';
                            }
                        }
                    }

                } catch (error) {
                    console.error('Error updating system status:', error);
                    // Set all to offline on error
                    const systemDiscordStatus = document.getElementById('system-discord-status');
                    const systemTwitchStatus = document.getElementById('system-twitch-status');
                    const systemObsStatus = document.getElementById('system-obs-status');

                    if (systemDiscordStatus) systemDiscordStatus.className = 'status-dot offline';
                    if (systemTwitchStatus) systemTwitchStatus.className = 'status-dot offline';
                    if (systemObsStatus) systemObsStatus.className = 'status-dot offline';
                }
            }

            // Utility function for showing messages
            function showMessage(elementId, message, type) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = message;
                    element.className = `status-message ${type}-message`;

                    // Clear message after 5 seconds for success/error, 3 seconds for warning
                    const timeout = type === 'warning' ? 3000 : 5000;
                    setTimeout(() => {
                        element.textContent = '';
                        element.className = '';
                    }, timeout);
                }
            }

            // Initialize new dashboard features
            async function initializeDashboard() {
                await loadOBSScenes();
                await updateSystemStatus();
            }

            // Load data on page load
            loadData();

            // Initialize new features
            setTimeout(initializeDashboard, 1000);

            // Stream status needs more frequent updates when transitioning live/offline
            setInterval(loadData, 45000);  // Check every 45 seconds for stream status
            // Update system status less frequently to reduce load
            setInterval(updateSystemStatus, 90000);  // Every 90 seconds for Discord/Twitch/OBS
            // Refresh OBS scenes less frequently to avoid status bar jumping
            setInterval(loadOBSScenes, 120000);  // Every 2 minutes for OBS scenes
        </script>
</body>

</html>